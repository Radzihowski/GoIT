Умовні оператори, цикли
Умовне виконання коду


За замовчуванням у Python інструкції виконуються одна за одною зверху вниз. Послідовність виконання виразів у програмі називається «потік виконання» (Flow of execution).



У Python існує три способи управління потоком виконання:



умовне виконання — виконання блоку інструкцій тільки за деякої умови;
цикли — повторення виконання блоку інструкцій, доки виконується деяка умова;
винятки — механізм обробки помилок, що дозволяє керувати потоком програми при виникненні виняткових ситуацій (наприклад, помилок або інших непередбачених обставин).


У Python умовне виконання, цикли та винятки формують основу управління потоком виконання програми, дозволяючи розробляти складні та гнучкі алгоритми обробки даних і взаємодії з користувачем.



Умовний оператор в Python - це конструкція мови, яка дозволяє виконувати певні дії в залежності від того, чи виконується певна умова.



Умовний оператор у Python має такий синтаксис:



if <умова>:
    <тіло if-блоку>
else:
    <тіло else-блоку>



if <умова>: вираз, який повертає True або False
<тіло if-блоку> це набір інструкцій, які виконуються, якщо умова є True
<тіло else-блоку> це набір інструкцій, які виконуються, якщо умова є False. Блок else є необов'язковим і може бути опущеним.


На малюнку нижче ми бачимо, що виконання коду відрізняється, якщо значення змінної num є більшим, або меншим за 10.






Відображення картинки в коді може виглядати так:



✂️ Цей код можна запустити!

num = 15  # приклад значення для num

if num > 10:
    print("num більше за 10")
else:
    print("num не більше за 10")



Спочатку ми задаємо значення змінної num. Це може бути будь-яке значення для перевірки різних умов. Потім використовуємо умовний оператор if для перевірки, чи num більше за 10. Якщо умова num > 10 вірна, виконується код усередині блоку if і на екран виводиться повідомлення "num більше за 10".



Якщо умова не вірна, виконується код усередині блоку else, і на екран виводиться повідомлення "num не більше за 10".

Наприклад, розглянемо наступний код, який визначає, що число x є парним:



x = int(input('Введіть число: '))

if x % 2 == 0:
    print("Число x є парним.")
else:
    print("Число x є непарним.")



У цьому коді <умова> є x % 2 == 0. Якщо ця умова є істинною, тобто число x є парним, виводиться повідомлення "Число x є парним.". Якщо умова є хибною, тобто число x є непарним), виводиться повідомлення "Число x є непарним.".



Що робити, якщо в нас є низка умов? Для цього у Python реалізований оператор контролю виконання if ... elif ... else. Оператор контролю виконання дозволяє виконувати блоки інструкцій не завжди, а тільки тоді, коли буде виконана умова.



Синтаксис умовного оператора:



починається з ключового слова if, за яким йде умова;
після умови ставиться двокрапка і з нового рядка з відступом йде блок інструкцій, які будуть виконані, якщо умова виконується;
після блоку if може бути нуль або більше блоків elif, інтерпретатор послідовно перевірятиме усі умови elif зверху вниз, доки не знайде той, який виконується;
потім може бути один блок else, який виконується, якщо всі попередні умови не виконуються.


a = input('Введіть число')
a = int(a)
if a > 0:
    print('Число додатне')
elif a < 0:
    print("Число від'ємне")
else:
    print('Це число - нуль')




Під час виконання умовного оператора інтерпретатор Python перевіряє умови зверху вниз, доки не знайде те, яке виконується, потім виконає вираз для цієї умови та вийде з перевірки умов.



Але будьте уважні, бо досить легко в такому операторі зробити помилку. Подивіться на цей код нижче та визначте, що з ним не так?



a = input('Введіть число')
a = int(a)

if a > 0:
    print('Число додатне')
elif a == 1:
    print('Число дорівнює 1')
else:
    print("a <= 0")




Подивились? Основна проблема цього коду полягає в тому, що перевірка elif a == 1: є надмірною та ніколи не виконується, оскільки умова if a > 0: вже включає в себе випадок, коли a дорівнює 1. Якщо a дорівнює 1, то програма виведе 'Число додатне', а не 'Число дорівнює 1', як це могло б здатися. Отже цей рядок коду ніколи не буде виконаний, оскільки будь-яке число, рівне 1, вже задовольнить попередню умову a > 0. Це досить поширена помилка новачків програмування у розумінні логіки умовних операторів.



Виправлений варіант цього коду міг би виглядати так:



a = input('Введіть число')
a = int(a)

if a == 1:
    print('Число дорівнює 1')
elif a > 0:
    print('Число додатне')
else:
    print("a <= 0")



У цьому випадку перевірка на рівність 1 виконується першою, тому логіка коду стала правильною.

Логічні вирази


Умовний оператор if ... elif ... else у Python у якості умов може приймати змінні типу bool або будь-який вираз, який він виконає і результат перетворить в bool. Коли в якості умови в умовний оператор ми передаємо вираз, то вираз виконається, а результат його виконання буде перетворений в тип bool.



Для зручності у Python є механізм неявного приведення будь-якого типу до типу bool. Правила приведення до bool достатньо інтуїтивні.



Правило перше - число 0 приводиться до False (ціле, дійсне або комплексне). Це правило перетворення дуже важливе, оскільки дозволяє використовувати числові змінні безпосередньо в умовних виразах. Наприклад, у коді нижче ми пишемо if money: і якщо money дорівнює 0, умова вважається неправдивою, і виконується код у блоку else.



✂️ Цей код можна запустити!

money = 0
if money:
    print(f"You have {money} on your bank account")
else:
    print("You have no money and no debts")



Це робить код чистішим і більш зрозумілим, оскільки не потрібно явно порівнювати money == 0, щоб перевірити, чи є гроші.



Правило друге - значення None приводиться до False. У коді нижче, якщо змінна result має значення None, умова if result: оцінюється як False, тому що None завжди вважається неправдивим (False) у булевому контексті. Таким чином в нас result є None, а значить виконується код у блоку else, і на екран виводиться повідомлення "Result is None, do something".



✂️ Цей код можна запустити!

result = None
if result:
    print(result)
else:
    print("Result is None, do something")



Правило третє - порожній контейнер, порожній рядок тощо, приводиться до False. Розглянемо для прикладу просту взаємодію з користувачем та умовного виконання.



user_name = input("Enter your name: ")

if user_name:
    print(f"Hello {user_name}")
else:
    print("Hi Anonym!")



Спочатку ми просимо користувача ввести своє ім'я за допомогою функції input(), і результат цього вводу зберігається у змінній user_name.



user_name = input("Enter your name: ")



Потім відбувається перевірка умови за допомогою оператора if. Умова перевіряє, чи змінна user_name не є порожньою. Якщо користувач ввів ім'я (тобто user_name містить непорожній рядок), умова оцінюється як True, і виконується блок коду після if.



print(f"Hello {user_name}")



У цьому випадку на екран виводиться привітання з введеним ім'ям. Якщо користувач просто натиснув Enter, не вводячи ім'я, а отже змінна user_name є порожнім рядком, умова оцінюється як False, і виконується блок коду після else. У цьому випадку на екран виводиться привітання "Hi Anonym!".



Правило останнє - все інше приводиться до True

Ці правила приведення до bool дозволяють писати умовні вирази у Python практично літературною англійською. В будь-якому разі, такий код стає дуже зрозумілим.





Оператор is



Оператор is у Python використовується для перевірки того, чи два об'єкти вказують на одну і ту ж область пам'яті, тобто чи вони є одним і тим же об'єктом.



Цей оператор відрізняється від оператора ==, який перевіряє рівність значень об'єктів.



Оператор is у Python використовується для перевірки ідентичності об'єктів, тобто для встановлення, чи дві змінні вказують на один і той самий об'єкт в пам'яті. Цей оператор, який часто називають оператором ідентичності, має особливе значення при роботі з незмінними типами даних, такими як числа та рядки. У випадку з незмінними типами даних Python може кешувати об'єкти, що іноді призводить до того, що оператор is повертає True для об'єктів з однаковими значеннями, як у випадку з дуже малими цілими числами або короткими рядками. Корисно мати цю інформацію для випадку, якщо ви зіткнетеся з таким винятком у своєму коді.



✂️ Цей код можна запустити!

a = [1, 2, 3]
b = a
c = [1, 2, 3]

print(a is b)  # True
print(a is c)  # False



У цьому прикладі, b є тим самим об'єктом, що й a, тому що вони вказують на один і той же список. Натомість c створює новий список, який містить ті самі значення, але фізично є окремим об'єктом.



Однак основне його застосування - це перевірка, чи змінна є None.



if my_var is None:
    # Робимо щось, якщо 'my_var' є 'None'



Таке використання is є оптимальним, оскільки існує лише один об'єкт None у Python.



Отже оператор is повинен використовуватися для перевірки ідентичності об'єктів, коли важливо, щоб дві змінні вказували на один і той же об'єкт. А оператор == повинен використовуватися для перевірки рівності значень двох об'єктів.

Булева алгебра


Що робити, якщо у нас складна умова, яка поєднує в собі декілька вкладених умов? Наприклад, щоб користувач міг орендувати автомобіль, потрібно, щоб у користувача обов'язково було вказане ім'я, користувач був старший 18 і були водійські права.



В коді це виглядає наступним чином.



✂️ Цей код можна запустити!

name = "Taras"
age = 22
has_driver_licence = True

if name and age >= 18 and has_driver_licence:
    print(f"User {name} can rent a car")



Ми бачимо, що тут з'явилися нова операція з and. В Python для побудови логічних умов з декількох, використовується булева алгебра.



Булева алгебра — це галузь математики, яка займається вивченням істинності виразів та їх обробкою. Вона названа на честь Джорджа Буля, англійського математика, який зробив значний внесок у цю область. Булева алгебра стала фундаментом для розвитку цифрової логіки та комп'ютерних наук.



У найпростішій формі булева алгебра оперує з двома значеннями: True (істина) і False (неправда). Тому у програмуванні застосовують бінарну логіку, де можливі значення також можуть бути True та False.



Булева алгебра будується на трьох основних операціях: "і", "або", "ні".



☝ Існують ще допоміжні операції, але ми розглянемо основні.


Основні операції в булевій алгебрі включають:



AND (і): Операція повертає True, якщо обидва операнди є True. Наприклад, True AND True є True, в той час як True AND False є False.
OR (або): Операція повертає True, якщо хоча б один з операндів є True. Наприклад, True OR False є True.
NOT (ні): Унарна операція, яка інвертує значення; True стає False, а False стає True.


Комбінація булевих значень і операцій формує складніші умови. Наприклад, вираз (True AND False) OR (True AND NOT False) використовує декілька булевих операцій.



У Python оператори булевої алгебри — це оператори not, and, or. Булева алгебра є ключовою для умовних операторів та логічних умов в програмуванні. Вона дозволяє контролювати потік виконання програми (наприклад, за допомогою if-else умов в Python) та виконувати складні логічні перевірки.



Наприклад, нам треба визначити, чи введене користувачем число є парним двозначним числом:



num = int(input("Введіть число: "))

length = len(str(num))

if length == 2 and num % 2 == 0:
    print("Парне двозначне число")
else:
    print("Ні")



Змінна length = len(str(num)) перетворює число в рядок str(num) і обчислює його довжину за допомогою функції len(). Ця довжина використовується для перевірки, чи число є двозначним.



Далі умова if length == 2 and num % 2 == 0: перевіряє дві речі. Чи довжина числа length дорівнює 2 та чи число num є парним. Якщо обидві умови вірні, виводиться повідомлення "Парне двозначне число". Якщо умова в if не виконується, тобто число не є парним двозначним, виконується код після else, і виводиться повідомлення "Ні".



У булевій алгебрі також важливі поняття булевої функції та булевих таблиць істинності, які використовуються для опису та аналізу логічних операцій. Булеві оператори в Python, такі як and, or, і not, є основними інструментами для побудови складних логічних умов. Вони використовуються для оцінки істинності або неправдивості виразів та є ключовими у процесі прийняття рішень у програмах.





Оператор and (і)



Оператор and використовується для перевірки, чи обидві умови є істинними. Вираз з and вважається True тільки тоді, коли обидва операнди істинні.



Наприклад:



a = True and False  # False

Таблиця істинності для and:






Ця таблиця показує, що вираз A and B буде істинним тільки тоді, коли обидва операнди A і B істинні.





Оператор or (або)



Оператор or перевіряє, чи хоча б одна з умов є істинною. Вираз із or вважається True, якщо принаймні один із операндів є істинним:



a = True or False  # True



Таблиця істинності для or:






З таблиці видно, що вираз A or B є істинним у всіх випадках, крім випадку, коли обидва операнди є неправдивими.





Оператор not (ні)



Оператор not використовується для інвертування істинності операнду. Якщо операнд істинний, not перетворює його на неправдивий, і навпаки:



a = not 2 < 0  # True



У цьому прикладі, оскільки 2 < 0 є неправдивим (False), оператор not перетворює його на True.



Таблиця істинності для not:






На останок розглянемо завдання "FizzBuzz”. Завдання часто зустрічається на співбесідах з програмування. Його суть полягає в написанні програми, яка для заданого числа:



Виводить "Fizz", якщо число кратне якомусь певному числу (наприклад, 3);
Виводить "Buzz", якщо число кратне іншому певному числу (наприклад, 5);
Виводить "FizzBuzz", якщо число кратне обом цим числам;
В іншому випадку виводить саме число.


На перший погляд це досить проста задача, але навіть досвідчені програмісти можуть тут помилитися. Задача "FizzBuzz" часто вважається базовим тестом на здатність кандидата розуміти та застосовувати основні концепції програмування. Хоча вона може здатися простою, її ефективне вирішення вимагає злагодженого застосування декількох основних програмувальних принципів.



# Задаємо конкретне число
num = int(input())

# Перевіряємо кратність
if num % 3 == 0 and num % 5 == 0:
    print("FizzBuzz")
elif num % 3 == 0:
    print("Fizz")
elif num % 5 == 0:
    print("Buzz")
else:
    print(num)



Умова if num % 3 == 0 and num % 5 == 0 перевіряє, чи введене число кратне і 3, і 5 одночасно. Ця перевірка стоїть першою, оскільки вона є найспецифічнішою.



Якщо ця умова виконується, виводиться "FizzBuzz". Якби ця перевірка була після інших, вона б ніколи не виконувалася, тому що більш загальні умови (кратність 3 або 5) вже б були виконані. Далі elif num % 3 == 0 перевіряє, чи число кратне тільки 3. Ця умова виконується тільки якщо попередня умова (кратність і 3, і 5) не виконалася. Якщо це правда, виводиться "Fizz". Умова elif num % 5 == 0 перевіряє, чи число кратне тільки 5. Як і попередня, ця умова виконується лише тоді, коли попередні перевірки не виявилися істинними. У випадку виконання цієї умови виводиться "Buzz". Якщо жодна з вищезазначених умов не виконалася, то else гарантує, що буде виведене саме число.



Порядок цих умов є ключовим, бо він забезпечує, що найспецифічніша перевірка - кратність і 3, і 5 має пріоритет, а потім перевіряються менш специфічні випадки - кратність окремо 3 або 5. Це запобігає випадкам, коли числа, які кратні і 3, і 5, були б неправильно оброблені через виконання менш специфічних умов.

Блоки інструкцій та тернарні оператори


У Python особливий синтаксис стосовно виділення блоків інструкцій. Щоб інтерпретатор сприйняв набір інструкцій як окремий блок, достатньо виділити всі інструкції цього блоку однаковою кількістю відступів зліва. У Python рекомендується для виділення одного рівня вкладеності для блоку інструкцій використовувати 4 пробіли.



x = int(input("X: "))
y = int(input("Y: "))

if x == 0:
    print("X can`t be equal to zero")
    x = int(input("X: "))

result = y / x




Ви можете використати символи табуляції для виділення блоку інструкцій, це не помилка, але такий спосіб не рекомендується.

Синтаксичною помилкою буде змішати в одному файлі виділення блоків за допомогою табуляцій та пробілів одночасно, пам'ятайте про це.



Також можна виділяти декілька рівнів вкладеності, додаючи ще 4 пробіли зліва для всіх інструкцій блоку:



x = int(input("X: "))
y = int(input("Y: "))

if x == 0:
    print("X can`t be equal to zero")
    x = int(input("X: "))

    if x == 0:
        print("X can`t be equal to zero")
        x = int(input("X: "))

        if x == 0:
            print("X can`t be equal to zero")
            x = int(input("X: "))

result = y / x




В цьому прикладі тричі повторюється перевірка на нерівність x нулю, і на кожну перевірку блок інструкцій виділяється додатковими 4-ма пробілами. Сенсу в додаткових перевірках немає, це зроблено тільки заради демонстрації.



Наведемо наступний приклад вкладеності для визначення чвертей для координатної площини, щоб закріпити розуміння блоку інструкцій. Даний фрагмент коду реалізує визначення квадранту точки з координатами x та y на координатній площині.



✂️ Цей код можна запустити!

if x >= 0:
    if y >= 0:  # x > 0, y > 0
        print("Перша чверть")
    else:  # x > 0, y < 0
        print("Четверта чверть")
else:
    if y >= 0:  # x < 0, y > 0
        print("Друга чверть")
    else:  # x < 0, y < 0
        print("Третя чверть")




Умовні оператори вкладені один в одного, що означає, що перевірка умов відбувається поетапно, і якщо перша умова x >= 0 виконується, то програма переходить до внутрішнього блоку і перевіряє умову y >= 0. Якщо ця умова також виконується, то точка знаходиться в першій чверті. Якщо умова y >= 0 не виконується, то точка знаходиться в четвертій чверті.



Якщо умова x >= 0 не виконується, то програма переходить до наступного внутрішнього блоку, але вже для оператора else, де виконується перевірка умови y >= 0. Якщо ця умова виконується, то точка знаходиться в другій чверті, якщо ні - у третій чверті.



Отже, в результаті виконання даного коду буде виведена назва чверті, в якій знаходиться точка з координатами (x, y).





Тернарні операції



Тернарні оператори в Python є елегантним способом вираження умовних виразів у скороченій формі. Вони дозволяють вам вибирати між двома значеннями залежно від того, чи є певна умова істинною або неправдивою. Це робить код компактнішим і часто полегшує його читання.



У прикладі нижче, вираз state = "nice" if is_nice else "not nice" використовує тернарний оператор для присвоєння рядка "nice" змінній state, якщо is_nice є істинним True, і рядка "not nice", якщо is_nice є неправдивим False:



is_nice = True
state = "nice" if is_nice else "not nice"



У цьому прикладі значенням змінної state буде рядок 'nice'.

Такий підхід дозволяє швидко перевірити умову, а не писати декілька рядків оператора if ... else .... Для порівняння, ось як виглядав би той самий вираз без використання тернарного оператора, а з використанням стандартного блоку if-else:



is_nice = True
if is_nice:
    state = "nice"
else:
    state = "not nice"



Ця версія коду робить те саме, що й тернарний оператор, але займає більше місця і є менш компактною.



Ще одним корисним варіантом тернарного оператора в Python є використання оператора or для швидкого визначення значення.



some_data = None
msg = some_data or "Не було повернено даних"



В прикладі ми присвоїмо msg значення some_data, якщо some_data не є None (або іншим значенням, яке вважається неправдивим у Python, як False, порожній рядок, порожній список тощо). У випадку, якщо some_data є None або неправдивим, msg отримає значення "Не було повернено даних". В нашому випадку msg буде містити рядок 'Не було повернено даних', це зручно, коли потрібно швидко перевірити значення та показати повідомлення, якщо значення some_data є None.



Без використання скороченої форми тернарного оператора з or, вираз msg = some_data or "Не було повернено даних" може бути переписаний з використанням стандартного умовного оператора if ... else ... наступним чином:



some_data = None
if some_data:
    msg = some_data
else:
    msg = "Не було повернено даних"



Цей варіант коду, хоч і більш довгий і менш компактний, може бути більш зрозумілим для новачків або у випадках, коли потрібна більш чітка логіка умови.



☝ Зверніть увагу, що для скороченої форми використовується саме оператор or (АБО).
Оператор match


Оператор match, введений у Python починаючи з версії 3.10, є схожим на оператори switch-case в інших мовах програмування. Він дозволяє порівнювати значення з декількома шаблонами і виконувати різні блоки коду в залежності від того, який шаблон відповідає значенню.





Структура оператора match



match змінна:
    case шаблон1:
        # виконати код для шаблону 1
    case шаблон2:
        # виконати код для шаблону 2
    case _:
        # виконати код, якщо не знайдено відповідностей



Оператор match - це свого роду розширена і більш гнучка версія оператора if-elif-else. Він дозволяє порівнювати значення з рядом шаблонів і, залежно від відповідності, виконувати певні дії.



✂️ Цей код можна запустити!

fruit = "apple"

match fruit:
    case "apple":
        print("This is an apple.")
    case "banana":
        print("This is a banana.")
    case "orange":
        print("This is an orange.")
    case _:
        print("Unknown fruit.")



У прикладі fruit - це змінна, значення якої ми хочемо перевірити:



fruit = "apple"



Далі оператор match порівнює значення змінної fruit з кожним значенням case послідовно. Якщо fruit дорівнює "apple", то виконується блок коду під case "apple":, і на екран виводиться "This is an apple."



case "apple":
    print("This is an apple.")



Якщо fruit дорівнює "banana", то виведеться "This is a banana.", і так далі для "orange". Але якщо жоден з варіантів не відповідає значенням case (тобто fruit не є ні "apple", ні "banana", ні "orange"), то виконується блок коду під case _:.



Символ _ тут використовується як "заглушка" для вказівки на будь-які інші випадки, які не відповідають переліченим. У цьому випадку на екран виведеться "Unknown fruit.".



case _:
    print("Unknown fruit.")



Цей оператор був введений для випадків, коли нам потрібно виконати різні дії в залежності від значення однієї змінної, особливо коли таких варіантів багато. Раніше для цього ми використовували довгий ланцюжок if-elif-else, але тепер оператор match робить код чистішим та простішим для розуміння.



Але оператор має більш розширену сферу використання. Наприклад використання змінних у шаблонах. Розглянемо приклад:



✂️ Цей код можна запустити!

point = (1, 0)

match point:
    case (0, 0):
        print("Точка в центрі координат")
    case (0, y):
        print(f"Точка лежить на осі Y: y={y}")
    case (x, 0):
        print(f"Точка лежить на осі X: x={x}")
    case (x, y):
        print(f"Точка має координати:  x={x}, y={y}")
    case _:
        print("Це не точка")



Якщо значення point = (1, 0) то спрацює case (x, 0): і ми отримаємо виведення Точка лежить на осі X: x=1. Якщо значення point = (1, 1) то спрацює вже case (x, y): та буде вивід "Точка має координати: x=1, y=1". В прикладі використовується match для порівняння point з декількома шаблонами. Якщо point відповідає одному з цих шаблонів, виконується відповідний блок коду.



Також можна використовувати оператор match з колекціями. Наприклад ми маємо список pets, який містить назви домашніх тварин.



✂️ Цей код можна запустити!

pets = ["dog", "fish", "cat"]

match pets:
    case ["dog", "cat", _]:
        # Випадок, коли є і собака, і кіт
        print("There's a dog and a cat.")
    case ["dog", _, _]:
        # Випадок, коли є тільки собака
        print("There's a dog.")
    case _:
        # Випадок для інших комбінацій
        print("No dogs.")



В цьому випадку виведення буде "There's a dog.", бо тільки "dog" знаходиться на своєму місці. Тут match використовується для перевірки, чи містить список pets певні комбінації тварин. Причому важливо, що саме комбінації, і саме тому в нас спрацював case ["dog", _, _]:, а не case ["dog", "cat", _]:, бо cat в списку pets знаходиться в кінці, а не після dog. Знак _ в шаблоні використовується як "заповнювач", що означає "будь-яке інше значення".

Цикли


Для того, щоб повторити якийсь блок коду кілька разів або повторювати, доки виконується деяка умова, у Python реалізовані цикли. Вони є фундаментальною конструкцією, яка дозволяє повторювати виконання певного блоку коду кілька разів.



Існують два основних типи циклів: for та while.:



Цикл for в Python використовується для ітерації по елементах будь-якої послідовності (наприклад, списку, кортежу, рядка) або інших ітерованих об'єктів;


for element in sequence:
    # виконувати дії з element



Цикл while виконує блок коду, поки задана умова є істинною (True). Як тільки умова стає неправдивою (False), цикл закінчується.


while condition:
    # виконувати дії, поки condition є True



Ітерація (лат. iteratio «повторювання») — повторювання будь-якої дії. Ітерація у програмуванні — організація обробки даних, за якої дії повторюються багаторазово, не призводячи, при цьому, до викликів самих себе. Одна ітерація — це одне повторювання.





Цикл for



У Python цикл for використовується для перебору усіх елементів контейнерів або ітерованих об'єктів, наприклад, списків. Інструкції, які знаходяться у тілі циклу, будуть виконані стільки разів, скільки елементів у колекції.



При цьому на кожній ітерації спеціальна змінна набуває значення одного з елементів колекції.



Роботу циклу for можна порівняти з тим, що ви по черзі візьмете кожну літеру з фрази й промовите її. Фразою може виступати рядок 'apple', а аналогом вимовлення вголос буде виступати виведення відповідної літери в консоль.



✂️ Цей код можна запустити!

fruit = 'apple'
for char in fruit:
    print(char)



У результаті виконання цього коду ви побачите в консолі:



a
p
p
l
e



Синтаксис циклу for в Python включає кілька важливих компонентів:



Цикл починається з ключового слова for, що вказує на початок циклу.
Після for слідує назва змінної, яка буде використовуватися для зберігання поточного значення ітерації. Значення цієї змінної буде змінюватися з кожною ітерацією циклу.
Далі йде ключове слово in, що вказує на об'єкт або діапазон, по якому буде відбуватися ітерація.
Після in розміщується об'єкт або вираз, що визначає набір елементів або діапазон, по якому буде відбуватися ітерація.
В кінці рядка ставиться двокрапка :, що відділяє заголовок циклу від його тіла.
На новому рядку з відступом від початку рядка розміщуються інструкції або вирази, які потрібно виконувати на кожній ітерації. Відступ є обов'язковим, оскільки він визначає блок коду, який належить до циклу.


Розглянемо декілька прикладів, щоб краще розуміти як працює цикл for. По будь-якій колекції можна пройти за допомогою циклу for і на кожній ітерації в циклі буде отримано один з елементів цієї колекції.



✂️ Цей код можна запустити!

alphabet = "abcdefghijklmnopqrstuvwxyz"
for char in alphabet:
    print(char, end=" ")



У прикладі літери алфавіту з alphabet виводяться в консоль по черзі, через пробіл.



 a b c d e f g h i j k l m n o p q r s t u v w x y z



Використаємо цикл for у Python для ітерації по елементах ітерованого об'єкта, у нашому випадку — списку some_iterable.



✂️ Цей код можна запустити!

some_iterable = ["a", "b", "c"]

for i in some_iterable:
    print(i)



У консолі ми побачимо:



a
b
c



Цикл for використовується для послідовного проходження по кожному елементу списку some_iterable. В цьому циклі i є змінною, яка на кожній ітерації приймає значення поточного елемента з some_iterable. На кожній ітерації виконується команда print(i), яка виводить поточний елемент списку.



Цикл for може використовуватися для перебору всіх чисел у списку та отримання результату для кожного числа:



✂️ Цей код можна запустити!

odd_numbers = [1, 3, 5, 7, 9]
for i in odd_numbers:
    print(i ** 2)



Код з цього прикладу виведе в консоль квадрати чисел списку odd_numbers.



1
9
25
49
81



Розглянемо наступну задачу. Користувач вводить рядок. Треба порахувати скільки символів в рядку та скільки пробілів в рядку. Як ми можемо написати код?



Ми повинні скласти порядок дій для розв'язання цієї задачі:



Зчитування рядка від користувача.
Використання циклу for для перебору кожного символу в рядку.
Підрахунок загальної кількості символів та окремо кількості пробілів за допомоги циклу for та оператору if.


Ось приклад коду на Python, який реалізує цю логіку:



# Зчитування рядка від користувача
user_input = input("Введіть рядок: ")

# Ініціалізація змінних для підрахунку символів та пробілів
total_chars = len(user_input)  # загальна кількість символів у рядку
space_count = 0  # кількість пробілів

# Підрахунок кількості пробілів
for char in user_input:
    if char == " ":
        space_count += 1

# Виведення результатів
print(f"Загальна кількість символів у рядку: {total_chars}")
print(f"Кількість пробілів у рядку: {space_count}")



У цьому коді вираз len(user_input) використовується для підрахунку загальної кількості символів у введеному рядку. Цикл for проходить через кожен символ у рядку, і якщо символ є пробілом, умова char == " ", змінна space_count інкрементується (збільшується) на 1. В кінці, виводяться обидва результати - це загальна кількість символів та кількість пробілів.





Цикл while



Цикл while у Python — це один із способів організації циклічного виконання коду. Він продовжує виконувати блок інструкцій, поки задана умова залишається істинною. Цикл while часто використовується, коли кількість ітерацій заздалегідь невідома або коли ітерації залежать від змінних, які можуть бути модифіковані в процесі виконання циклу.



Синтаксис циклу while наступний:



while condition:
    # Блок коду для виконання



condition (умова) — це логічний вираз, який перевіряється перед кожною ітерацією циклу. Якщо умова істинна True, код усередині блоку while виконується. Як тільки умова стає неправдивою False, виконання циклу припиняється.



Розглянемо приклад



✂️Цей код можна запустити!

k = 0
while k < 10:
    k = k + 1
	print(k)



У цьому прикладі, цикл while виконуватиметься, поки змінна k менша за 10. На кожній ітерації k збільшується на 1, і виводиться значення k. Коли змінна k досягає значення 10, умова k < 10 стає неправдивою, і цикл припиняється.






При використанні циклів while важливо забезпечити, що умова циклу змінюватиметься в процесі його виконання, щоб уникнути нескінченних циклів.





«Нескінченні цикли» та break



Бувають ситуації, коли необхідно вийти з циклу до завершення ітерації, не дочекавшись, доки станеться чергова перевірка умови. Для цього є команда break. Команда break зупиняє цикл в момент виклику і не завершує ітерацію.



a = 0
while True:
    print(a)
    if a >= 20:
        break
    a = a + 1



В цьому прикладі умова циклу буде виконуватися завжди, адже True завжди буде True. Це приклад нескінченного циклу. Але через перевірку, що a >= 20, цей цикл завершиться, щойно в a буде значення 20 або більше.



Нескінченні цикли часто застосовуються там, де потрібно взаємодіяти з клієнтом, чекаючи введення від нього, і завершується тільки при настанні деякої умови.



Наприклад echo скрипт, який виводить в консоль те, що ви введете, доки ви не введете рядок тексту exit:



while True:
    user_input = input()
    print(user_input)
    if user_input == "exit":
        break





Завершення ітерації за допомогою continue



Також для того, аби одразу перейти до наступної ітерації циклу без виконання виразів, що залишилися, є команда continue. Виклик цієї команди у тілі циклу призводить до того, що вирази цієї ітерації, що залишилися, не будуть виконані, а інтерпретатор одразу перейде до наступної ітерації або перевірки умови.



✂️ Цей код можна запустити!

a = 0
while a < 6:
    a = a + 1
    if not a % 2:
        continue
    print(a)



У консолі ви побачите:



1
3
5



Інструкція print(a) не виконувалась, коли a ділилося на 2 без залишку, оскільки ітерація завершувалася за допомогою continue.



В цьому прикладі використовувався оператор отримання залишку від ділення %, він повертає таке число p, що якщо його відняти від r, то результат буде ділитися на x націло: (r - p) / x = a, де а, x, r — цілі числа.



for i in range(1, 10):
    if i % 2 == 0:
        print(f”{i} є парним числом.“)
    else:
        print(f”{i} є непарним числом.“)



Оператори continue та break працюють тільки всередині одного циклу. В ситуації вкладених циклів немає способу вийти з усіх циклів одразу.



while True:
    number = input("number = ")
    number = int(number)
    while True:
        print(number)
        number = number - 1
        if number < 0:
            break



В цьому прикладі користувач вводить число та отримує зворотний відлік від цього числа до 0 в консолі. При цьому, зовнішній нескінченний цикл жодним чином не перервати і break вийде тільки з внутрішнього циклу.



Також використання continue або break поза циклом призводить до синтаксичної помилки.



number = int(input("number = "))
if number < 0:
    break



Такий код призводить до помилки SyntaxError. Такі помилки називаються винятками.

Розширення можливостей циклу for


Зараз ми розглянемо три ключові функції Python, які забезпечують потужні і гнучкі способи для ітерації, або повторення певних дій: range, enumerate та zip.



Ці функції є фундаментальними для ефективного використання циклів for та відіграють важливу роль у різноманітних програмувальних задачах. Розуміння та застосування цих функцій допоможе підвищити ефективність нашого коду.



Функція range важлива для створення послідовностей чисел, які ви можете використовувати у циклах. Вона надзвичайно корисна, коли вам потрібно виконати дію певну кількість разів або ітерувати через послідовність чисел.
Коли вам потрібно отримати доступ не тільки до значення з ітерованої колекції, але до її індексу, тут функція enumerate стає незамінним помічником. Ця функція дозволяє вам легко отримувати доступ до індексу кожного елементу під час ітерації.
Функція zip використовується для одночасної ітерації по кількох колекціях. Якщо вам потрібно комбінувати дані з різних джерел або виконувати операції, які залежать від декількох пов'язаних колекцій, zip дозволяє це зробити легко та елегантно.


Розглянувши кожну з цих функцій, ми зможемо значно розширити свої навички роботи з циклами та колекціями в Python, створюючи більш потужний та виразний код.





Функція Range



Функція range у поєднанні з циклом for у Python є потужним інструментом для контролю повторення дій певну кількість разів. Цей механізм часто використовується для ітерації через послідовність чисел, що робить його особливо корисним для різних задач, від базових до складних алгоритмів.



Функція range створює послідовність чисел. Вона може бути використана різними способами:



range(stop): Створює послідовність чисел від 0 до stop - 1.
range(start, stop): Генерує числа від start до stop - 1.
range(start, stop, step): Створює числа від start до stop - 1, з кроком step.





Цей приклад використовує цикл for разом з range для ітерації через послідовність чисел.



✂️ Цей код можна запустити!

for i in range(5):
    print(i)



У цьому прикладі range(5) генерує послідовність чисел від 0 до 4. Цикл for проходиться по цій послідовності, і змінна i приймає значення кожного числа в послідовності по черзі. Це був приклад простої ітерації.



Ітерація з визначеним початком і кінцем ітерації. Приклад виведення чисел від 2 до 9.



✂️ Цей код можна запустити!

for i in range(2, 10):
    print(i)



Ітерація з кроком. Цей приклад виведе парні числа від 0 до 8.



✂️ Цей код можна запустити!

for i in range(0, 10, 2):
    print(i)



Функція range разом з циклом for є основою для структурованого повторення коду та важливою частиною багатьох алгоритмів і програм у Python. Вони дають можливість легко маніпулювати послідовностями чисел для вирішення різноманітних задач.





Функція Enumerate



Функція enumerate використовується для одночасного отримання індексу та значення елементів ітерованого об'єкта. Це корисно, коли вам потрібно отримати доступ до індексу елементів під час ітерації.






✂️ Цей код можна запустити!

some_list = ["apple", "banana", "cherry"]
for index, value in enumerate(some_list):
    print(index, value)



У цьому прикладі enumerate(some_list) створює пари індекс-значення для кожного елемента в списку, і цикл for проходить по цих парах.

Виведення:



0 apple
1 banana
2 cherry





Функція Zip



Функція zip використовується для ітерації по декількох ітерованих об'єктах одночасно. Вона "застібає" елементи з кожного ітерованого об'єкта, створюючи кортежі з цих елементів.






✂️ Цей код можна запустити!

list1 = ["зелене", "стигла", "червоний"]
list2 = ["яблуко", "вишня", "томат"]
for number, letter in zip(list1, list2):
    print(number, letter)



У цьому випадку zip(list1, list2) об'єднує елементи з list1 та list2, і цикл for проходить по створеним словосполученням.

Виведення:



зелене яблуко
стигла вишня
червоний томат



Коли колекції, передані в zip, мають різну довжину, zip обробляє елементи до тих пір, поки не закінчаться елементи в найкоротшій колекції. Це означає, що ітерація припиняється, як тільки буде досягнутий кінець однієї з колекцій, і будь-які додаткові елементи в інших, більш довгих колекціях, ігноруються.



✂️ Цей код можна запустити!

list1 = [1, 2, 3]
list2 = ['a', 'b', 'c', 'd', 'e']

for number, letter in zip(list1, list2):
    print(number, letter)



У цьому прикладі list1 має 3 елементи, тоді як list2 має 5 елементів. Оскільки list1 є коротшим, zip припинить ітерацію після третьої пари значень. Результат буде:



1 a
2 b
3 c



Елементи 'd' та 'e' з list2 у цьому випадку будуть проігноровані.



Тому обережно використовуйте zip з дуже великими колекціями, оскільки надлишкові елементи ігноруються, що може призвести до втрати даних або непередбачених результатів, якщо цей аспект ігнорувати.

Цикли та словники


Ітерування за словником — це такий блок коду, який дуже часто зустрічається при програмуванні, тож корисно вміти це робити.



Спершу варто сказати, що словник сам по собі — це ітерований контейнер і за ним можна ітеруватися в циклі for без необхідності заводити якийсь зовнішній лічильник тощо. Створимо словник, в якому ключами будуть числа, а значеннями — числівники англійською:



numbers = {
    1: "one",
    2: "two",
    3: "three"
}



Тепер давайте просто пройдемо словником в циклі та виведемо, що нам повертає ітератор на кожній ітерації:



✂️ Цей код можна запустити!

for key in numbers:
    print(key)

У виведенні ви побачите:

1
2
3



Ітеруючи за словником, ви перебираєте ключі словника. Таку саму поведінку можна отримати, використовуючи метод keys, але так ви явно вкажете, що хочете перебрати ключі:



✂️ Цей код можна запустити!

for key in numbers.keys():
    print(key)



Відповідь буде точно такою самою:



1
2
3



Часто необхідно перебрати саме значення словника, для цього скористаємося методом values:



✂️ Цей код можна запустити!

for val in numbers.values():
    print(val)



У виведенні буде:



one
two
tree






Щоб перебрати пари ключ значення словника треба використати метод items. На кожній ітерації ми отримаємо пару (ключ, значення):



✂️ Цей код можна запустити!

for key, value in numbers.items():
    print(key, value)



Виведення:



1 one
2 two
3 three






Важливо пам'ятати, що не можна робити, поки ітеруєтеся за словником: не можна видаляти елементи із словника, не можна додавати елементи у словник. Але можна перезаписувати значення, якщо ви ітеруєтеся за ключами. Теж саме стосуються і списку - не можна видаляти елементи списку та не можна додавати елементи у список під час ітерацій в циклі.

Винятки


Перетворити в int або float можна не будь-який рядок. Наприклад, якщо користувач введе 'a', то інтерпретатор не зможе визначити, як перетворити символ a в ціле число, і викличе виняток ValueError.



int("a")
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-6-d9136db7b558> in <module>
----> 1 int("a")

ValueError: invalid literal for int() with base 10: 'a'




Виключення у Python — це помилка на рівні інтерпретатора, викликана неможливістю виконати той або інший оператор з будь-яких причин (змінна не існує, синтаксична помилка, відсутній атрибут, операція ділення на нуль тощо).



У нашому прикладі (ввели 'а') інтерпретатор намагається перетворити рядок в тип int (ціле число), але як перетворити рядок 'a' у число не визначено і буде викликаний виняток із цього приводу.





Основні типи винятків у Python



SyntaxError — синтаксична помилка.

IndentationError — помилка, яка виникає, якщо у виділенні блоків інструкцій пробілами допущена помилка.

TabError виникає, якщо в одному файлі використовувати пробіли і табуляції для виділення блоків інструкцій.

TypeError виникає, коли операція зі змінною цього типу неможлива.



2 / 'a'



ValueError виникає, коли тип операнда відповідний, але значення таке, що операцію неможливо виконати.



int("a")



ZeroDivisionError — ділення на нуль.





Механізм обробки винятків



Для обробки винятків існує оператор try ... except .... Синтаксично цей оператор розпочинається з ключового слова try: (спробувати) та продовжується блоком коду, в якому ми чекаємо, що може статися помилка.



Далі йде блок обробки винятків except (крім), де можна вказати один або більше винятків. Якщо один із зазначених винятків станеться, то виконається наступний блок коду.



Цей блок не обов'язковий, але найчастіше потрібний. Він виконається, якщо станеться зазначений виняток (один із них, якщо їх декілька).



Якщо помилки можуть бути різні і обробляти їх потрібно теж по-різному, то можна додати декілька блоків except, у кожному вказати свою помилку і що робити, якщо вона станеться.



Потім іде необов'язковий блок, який розпочинається з ключового слова else. Цей код виконається, тільки якщо винятків не сталося.



Останнім іде необов'язковий блок коду, який розпочинається з ключового слова finally, він виконається у будь-якому разі, незалежно від того, були помилки або ні.



У нашому прикладі обробка призначеного для користувача введення виглядатиме таким чином:



✂️ Цей код можна запустити!

val = 'a'
try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print(val > 0)
finally:
    print("This will be printed anyway")



Винятки у Python — це дуже потужний інструмент, який часто використовується для управління потоком виконання, а не тільки для обробки помилок. У динамічних мовах ніколи не можна бути на 100% впевненим у тому, що користувач увів значення коректного типу, або що інший застосунок не повернув None замість int, наприклад.



Наївним розв'язанням цієї проблеми буде повсюдне використання перевірок if на коректність введеного користувачем або іншим застосунком значення. Просунутішим, зручнішим і прозорішим рішенням є використання механізму обробки винятків там, де вони можуть статися через некоректні вхідні дані.



age = input("How old are you? ")
try:
    age = int(age)
    if age >= 18:
        print("You are adult.")
    else:
        print("You are infant")
except ValueError:
    print(f"{age} is not a number")



💡 Нагадуємо, що f-рядок — це такий шаблон, який дозволяє зручним чином генерувати рядок, підставляючи результат виконання виразів у потрібне місце в шаблоні.
1. Який оператор у Python використовується для умовного виконання коду?

while
for
if ... elif ... else
try ... except
Результат

Вірно! Оператор if ... elif ... else у Python використовується для умовного виконання коду.

2. Як працюють вкладені умовні оператори в Python?

Вони виконуються паралельно
Вони виконуються поетапно
Вони виконуються тільки при помилці
Вони не підтримуються в Python