# Принцип єдиної відповідальності (Single responsibility)
#
# Принцип єдиної відповідальності (Single Responsibility Principle, SRP) означає, що у модуля повинна бути лише одна
# причина для зміни. Весь код, який змінюється з цієї причини, повинен бути зібраний у цьому модулі.

# Під причиною слід розуміти бізнес-причину. Такою причиною може бути відділ, який замовляє деякий функціонал, власник
# продукту, група користувачів тощо.
#
# Під модулем ми розумітимемо якусь частину коду, відокремлену від інших. Це може бути клас, функція, об'єкт, файл —
# загалом усе, що має межі і визначає код як самостійну одиницю.
#
# З SRP добре пов'язаний прийом – виділення класу. Це коли з великого класу з безліччю слабо-пов'язаних за змістом полів
# та методів, виділяється один або кілька класів. Суть у тому, щоб явно виділити призначення класу або, іншими словами,
# виділити клас, який можна описати однією фразою.
#
# Важливою непрямою ознакою правильно обраного класу буде наявність зручного, зрозумілого імені для цього класу, та ім'я повинно бути іменником з прикметником. Якщо доводиться використовувати віддієслівні іменники, то, найімовірніше, що призначення класу вибрано неправильно.
#
# Для розуміння цього принципу розглянемо наступний приклад:
class Person:
    def __init__(self, name, post_code, city, street):
        self.name = name
        self.post_code = post_code
        self.city = city
        self.street = street

    def get_address(self):
        return f'{self.street}, {self.city}, {self.post_code}'

person = Person('Timoty Snaider', 'AL15EU', 'London', 'European 28')
print(person.get_address())

# У нас є клас Person. Відповідно до принципу єдиної відповідальності клас повинен вирішувати лише якесь одне завдання.
# Зараз він вирішує два: зберігає дані користувача та виконує логіку перетворення адреси користувача.
#
# Необхідно зробити так, щоб клас Person працював тільки з даними користувача, а завдання перетворення адреси делегувалося
# іншому екземпляру класу PersonAddress через залежність у конструкторі.
class PersonalAddress:
    def __init__(self, post_code, city, street):
        self.post_code = post_code
        self.city = city
        self.street = street

    def value_of(self):
        return f'{self.street}, {self.city}, {self.post_code}'

class Person1:
    def __init__(self, name, address):
        self.name = name
        self.address = address

    def get_address(self):
        return self.address.value_of()

if __name__ == '__main__':
    person = Person1('Oleksandr', PersonalAddress('WC15GZ', 'London', 'Meclenburg Sqr, 101'))
    print(person.get_address())
