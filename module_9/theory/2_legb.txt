Області видимості (LEGB)
Область видимості — це область у програмі (коді), в межах якої ви можете звернутися за ім'ям до вмісту змінної (або як
ми вже з'ясували — функції). У Python можна виділити дві великі області видимості:
- глобальну (Global Scope). Все, що оголошено в цій області, буде доступне в будь-якій частині вашого застосунку;
- локальну (Local Scope). Все, що оголошено в локальній області видимості, буде доступно тільки всередині неї.

Глобальна область видимості лише одна і в ній міститься все, що ви оголосили на рівні модулю (змінні, функції, інші
модулі тощо).

Локальна область видимості створюється, коли інтерпретатор потрапляє всередину функції.

SOME_VAR = 3

def func(x):
    SOME_VAR = x
    print(SOME_VAR)

def procedure()
    print(SOME_VAR)

procedure()     # 3
func(5)         # 5
print(SOME_VAR) # 3


Давайте розберемо на цьому прикладі, як працюють області видимості. Змінна SOME_VAR оголошена на рівні модулю у
глобальній області видимості (так само як і функції func та procedure).

Коли ми викликаємо procedure всередині неї, створюється локальна область видимості. У локальній для procedure області
видимості немає SOME_VAR, і коли ми виконуємо вираз print(SOME_VAR), Python спочатку шукає SOME_VAR у локальній області
видимості, не знаходить, і йде шукати у глобальній, де і знаходить SOME_VAR рівне 3.

Коли ми викликаємо func, всередині неї створюється локальна область видимості. В цій локальній області ми створюємо
змінну SOME_VAR і присвоюємо їй значення 5. У цей момент глобальна область видимості жодним чином не змінюється,
нова SOME_VAR існує тільки всередині func. На підтвердження цього ми виконуємо print(SOME_VAR) на рівні модуля й
отримуємо 3, що каже про те, що всередині func існувала своя окрема змінна з ім'ям SOME_VAR.

Щоб краще розуміти, що таке зона видимості, варто зрозуміти як працює їх механіка.
У Python області видимості реалізовані як словники, в яких ім'я змінної або функції (рядок) — це ключ, а сам об'єкт — це
 значення в цьому словнику.

Таким чином, коли ви у коді виконали x = 2, в словнику простору імен (те саме, що й область видимості) додалася пара:
'x': 2. І коли десь далі вам потрібно отримати значення x з цього словника, буде взято значення 2, знайдене за ключем 'x'.

Коли створюється нова зона видимості (простір імен), то насправді створюється новий подібний словник (старий нікуди не
дівається звичайно ж).

Тут можна зробити важливий висновок, у вас в коді може одночасно існувати декілька просторів імен, які не взаємодіють
один з одним. Це у свою чергу означає, що пошук об'єктів за ім'ям повинен відбуватися за якимось правилом.

У Python правила пошуку імен дуже прості:
- спочатку пошук йде в локальному просторі імен (LOCAL);
- якщо не знайдено в локальному, то в локальному на наступному рівні (ENCLOSED) і так далі, доки локальні не закінчаться;
- далі буде перевірено глобальний (GLOBAL) простір імен (рівень модуля);
- і в останню чергу простір вбудованих імен (BUILT INS) — це ключові слова і функції, що є частиною мови Python.


Якщо ніде не знайдено сутності з таким ім'ям, то отримаємо виключення.



Це правило можна запам'ятати за його акронімом: (LOCAL, ENCLOSED, GLOBAL, BUILT INS).

У цьому правилі ми не розглянули, що таке ENCLOSED.

GLOBAL_SCOPE_VAR = 1

def func():
    enclosed_scope_var = 2
    def inner():
        inner_var = 3


В цьому коді всередині функції func оголошена функція inner. Для функції func enclosed_scope_var та inner — знаходиться
в LOCAL області видимості. Для функції inner змінна inner_var буде в її локальній області видимості, а вже
enclosed_scope_var буде в ENCLOSED, в локальному просторі, але на рівень вище.