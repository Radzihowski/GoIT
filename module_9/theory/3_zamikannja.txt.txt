Замикання
Особливість існування вкладених локальних просторів імен і той факт, що вони створюються динамічно, дає можливість
використати механізм замикань у Python.

Найпростіше це пояснити на прикладі:

def adder(val):
    def inner(x):
        return x + val
    return inner


two_adder = adder(2)
print(two_adder(3)) # 5
print(two_adder(5)) # 7

three_adder = adder(3)
print(three_adder(5))   # 8
print(three_adder(-3))  # 0

id(two_adder) == id(three_adder)    # False


В цьому прикладі ми створили функцію adder, яка повертає внутрішню функцію inner. Коли інтерпретатор заходить в adder
(наприклад, у виразі two_adder = adder(2)) створюється новий локальний простір імен в adder, де створюється функція
inner, яка і повертається з функції. Що не очевидно, так це те, що новостворена inner, коли її викликають, буде
використовувати те значення val, яке було в adder на момент її створення.

Коли ми виконали two_adder = adder(2), в two_adder записали функцію inner, яка буде додавати 2 до x. А коли виконали
three_adder = adder(3), то в three_adder записали inner, яка завжди буде додавати 3 до x.

two_adder та three_adder — це дві різні функції, про що каже результат перевірки їх ідентифікаторів
(вираз id(two_adder) == id(three_adder)).