# Концепцію замикання може добре пояснити приклад кешування значень функції.
#
# Підсумкове завдання модуля 3 було — рекурсивне обчислення чисел Фібоначчі.
#
# Ряд Фібоначчі - це послідовність чисел виду: 0, 1, 1, 2, 3, 5, 8, ..., де кожне наступне число послідовності виходить
# додаванням двох попередніх членів ряду.
#
# У загальному вигляді для обчислення n-го члена ряду Фібоначчі потрібно вирахувати вираз: Fn = Fn-1 + Fn-2.
#
# Це завдання можна вирішити рекурсивно, викликаючи функцію, що обчислює числа послідовності доти, доки виклик не сягне
# членів ряду менше n = 1, де послідовність задана.
#
# Створіть функцію caching_fibonacci(), яка матиме кеш із попередньо обчисленими значеннями чисел Фібоначі. Усередині
# вона містить функцію fibonacci(n), яка безпосередньо і обчислюватиме саме число Фібоначчі. Функція caching_fibonacci()
# повертає функцію fibonacci
#
# Якщо число Фібоначчі зберігається у словнику cache, то функція fibonacci повертає число з кеша. Якщо його немає у
# кеші, то ми обчислюємо число і поміщаємо його в кеш, і повертаємо з функції fibonacci.
def caching_fibonacci():
    cache = {0: 0, 1: 1, 2: 1}

    def fibonacci():
        result = 1
        for value in range(3, n+1):
            if value in cache:
                result = cache[value]
            else:
                print(f'this is {value} attempt')
                result = fibonacci(value - 1) + fibonacci(value - 2)
                print(f'after {value} we have {result}')
                cache[value] = result
                print(cache)
                print('{} not in cache {}'.format(value, result))
        return result
    return fibonacci

print(caching_fibonacci())
print(caching_fibonacci())
