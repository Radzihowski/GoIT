# Є ще один контейнер, з яким ми раніше не працювали. Це bytes — байтові рядки.
# Дані у пам'яті комп'ютера зберігаються у вигляді послідовності байтів. Відповідно, будь-які дані можна представити у
# вигляді послідовності байтів. Для роботи з "сирими" даними у Python є два типи даних: bytes та bytearray.
# Дуже багато протоколів досі працюють із "сирими" даними або просто потоком байтів, наприклад TCP/IP, послідовний порт,
# telnet і багато інших.
# Щоб працювати з послідовністю байтів у Python є вбудовані типи даних байт-рядків (bytes) та масиви байтів bytearray.
# За своєю суттю байт-рядки або простіше байти — це звичайні рядки, але для запису одного символу використовується
# суворо один байт.
# Байт — це одиниця зберігання та обробки цифрової інформації, що містить 8 біт інформації. Один біт — це 0 або 1.
# За допомогою одного байта можна записати будь-яке число від 0 до 255 включно.
# Для байт-рядків застосовуються ті самі обмеження і правила, що і для звичайних рядків:
# байт-рядки — незмінні;
# байт-рядки — послідовні і до їх елементів можна звертатися за індексом:
#

s = b'Hello!'
print(s[1]) # 101

# байт-рядки підтримують більшість методів рядків, таких як upper, startswith, index, find та інші.
# Створення байт-рядків

byte_string = b'Hello world!'

# В цьому прикладі у byte_string міститься послідовність символів по одному байту на кожного.
# Від оголошення звичайного рядку байт-рядок відрізняє наявність символу b перед самим рядком.
# Другий спосіб створення байт рядків — це перетворення у байт-рядок.
# Для перетворення рядка у байт-рядок можна скористатися методом рядків encode:

byte_str = 'some text'.encode()

# У byte_str буде записана послідовність байтів.
# В один байт поміщається число від 0 до 255 включно, відповідно можна перетворити послідовність чисел від 0 до 255 у
# байт-рядок за допомогою функції bytes:

numbers = [0, 128, 255]
byte_numbers = bytes(numbers)

# Виведення байт-рядків
# Для виведення байтів найзручніше скористатися шістнадцятковим записом, в якому для запису чисел від 0 до 255 достатньо
# двох символів. Саме такий запис використовує Python "за замовчуванням" для байтів.

some_numbers = bytes([127, 255, 156])
print(some_numbers) # b'\x7f\xff\x9c'

# Символ \x вказує на шістнадцятковий формат запису. Щоб перевірити правильність представлення, можна скористатися
# вбудованою функцією hex, яка перетворить ціле число в рядок — представлення числа в шістнадцятковій формі:

for num in [127, 255, 156]:
  print(hex(num))

#
# В результаті виконання ви побачите:
# 0x7f
# 0xff
# 0x9c
# В такому вигляді перші два символи 0x вказують на шістнадцяткову форму запису.

# Перші комп'ютери для роботи з текстом використовували так зване ASCII кодування. У цьому кодуванні для запису одного
# символу використовується один байт.
# Зручність цього кодування в тому, що будь-які дані на комп'ютері можна спробувати представити у вигляді тексту в цьому
# кодуванні. ASCII містить 256 символів. Це не дуже багато і деякий час цього було достатньо. Але з часом алфавіту з
# 256 символів стало мало, виникла необхідність додати все більше символів (кирилиця, діакритичні знаки, коди валют,
# ієрогліфи тощо). Щоб задовольнити потребу у додаванні нових символів, придумали використати кодування, де більше
# одного байту на символ. Python за замовчуванням використовує UTF-8, в якій один символ може займати від 1 до 4 байт,
# і всього в алфавіті може бути до 1 112 064 знаків. Це не єдине кодування, на різних платформах можуть бути присутні
# власні, наприклад CP-1251 (кирилиця на ОС сімейства Windows), UTF-16, UTF-32 та інші.
# Щоб дізнатися, якому елементу в UTF-8 відповідає символ, є функція ord (від order).
# Наприклад, символ 'a' кодується числом 97:

ord('a')  # 97

# Зворотна операція, коли потрібно дізнатися, який символ закодований числом, наприклад 100, є функція chr
# (скорочено від character):

chr(128)  # 'd'

# Python може працювати з дуже великою кількістю різних кодувань.

s = "Привіт!"

utf8 = s.encode()
print(utf8) # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82!'

utf16 = s.encode('utf-16')
print(utf16)  # b'\xff\xfe\x1f\x04@\x048\x042\x045\x04B\x04!\x00'

s_from_utf16 = utf16.decode('utf-16')
print(s_from_utf16 == s)  # True

# Спроба перетворити байт-рядок в неправильному кодуванні, призводить або до помилки, або до досить непередбачуваного
# результату:

print(b'Hello world!'.decode('utf-16')) # 效汬⁯潷汲Ⅴ

# Робота з рядками обмежена тим, що рядки і байт-рядки незмінні. Якщо потрібно замінити навіть один символ, потрібно,
# по суті, створити копію початкового рядка з єдиним відмінним символом. Щоб зменшити накладні витрати при роботі
# з "сирими" даними, в Python є такий контейнер як bytearray.

byte_array = bytearray(b'Kill Bill')
byte_array[0] = ord('B')
byte_array[5] = ord('K')
print(byte_array) # bytearray(b'Bill Kill')

# Основна відмінність від байт-рядків — це змінність, щоб змінити масив байтів, не потрібно створювати новий. Друга
# важлива відмінність — це те, що масив байтів сприймається системою як послідовність чисел від 0 до 255, а не як
# послідовність символів в ASCII кодуванні. Саме тому не можна написати byte_array[0] = b'B'. Елементи масиву байтів
# сприймаються саме як цілі числа.
# В іншому ж bytearray може використовуватися як заміна байт-рядків і у нього є ті самі методи з тією самою поведінкою.