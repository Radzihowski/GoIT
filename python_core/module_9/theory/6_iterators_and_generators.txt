Ітератори/генератори (ключове слово yield)
Функції — це ізольовані набори інструкцій з однією точкою входу і однією точкою виходу. Іншими словами, коли ви
викликаєте функцію, то інтерпретатор виконає увесь її код від початку і до кінця при кожному виклику.

Але, що якщо потрібно отримати такий ізольований набір інструкцій з декількома точками входу? Або, що якщо ми хочемо
продовжити виконання функції з якогось місця при наступному її виклику?

Прикладом таких ситуацій може слугувати генератор випадкових чисел, який при кожному виклику видає нове "випадкове"
число і не повторює вже виданих. Або, коли нам потрібна велика послідовність, яку можна легко обчислити і було б
невигідно зберігати в пам'яті повністю.

Подібні завдання у Python вирішують ітератори і генератори. Один із способів створити ітератор або генератор
у Python — це створити особливу функцію з декількома точками входу. Для цього використовується ключове слово yield.
yield поводиться схожим чином з return, повертає управління потоком виконання програмою з тіла функції. Але, на відміну
від return, yield при наступному зверненні не розпочинає виконання функції з початку, а продовжує з місця зупинки.

Звичайно така поведінка припускає, що десь в пам'яті повинна зберігатися інформація про те, на чому виконання зупинилося
і про стан локального простору імен.

def interval_generator(x, y):
    while x <= y:
        yield x
        x += 1


five_to_ten_generator = interval_generator(5, 10)

next(five_to_ten_generator) # 5
next(five_to_ten_generator) # 6
next(five_to_ten_generator) # 7
next(five_to_ten_generator) # 8
next(five_to_ten_generator) # 9
next(five_to_ten_generator) # 10


В цьому прикладі ми створили генератор цілих чисел від x до y interval_generator. Щоб створити генератор чисел від 5 до
10, ми викликали interval_generator, передавши як числа 5 та 10. Результат (сам генератор) зберегли в five_to_ten_generator.

Генератор — це не звичайна функція і, щоб отримати з нього значення, можна скористатися вбудованою функцією next.
Але це не найзручніший спосіб. Найчастіше генератори використовуються безпосередньо в циклах for ...:

def interval_generator(x, y):
    while x <= y:
        yield x
        x += 1


five_to_ten_generator = interval_generator(5, 10)
for i in five_to_ten_generator:
    print(i)


Результат виконання цього коду буде абсолютно ідентичний. Ви вже стикалися з генераторами у Python, наприклад range —
це генератор.

Принципова відмінність генератора від ітератора в тому, що генератор обчислює наступне значення деякої послідовності у
момент виклику, а ітератор перебирає збережену в пам'яті послідовність. З точки зору використання генератор та ітератор
абсолютно ідентичні.