Декоратори
Є такий шаблон проектування — Декоратор. Цей шаблон полягає в тому, щоб розширювати існуючий функціонал, не вносячи змін
в код цього самого функціоналу.

Наприклад, у нас є якась дуже складна і важлива функція complicated:

def complicated(x, y):
    return x / y


І ми не хочемо міняти її код з якоїсь причини. Але нам потрібно додати логування до цієї функції, виводити в консоль
щоразу, коли вона викликається, з якими аргументами її викликали і що вона повернула в результаті.

Пам'ятаючи про те, що функція — це об'єкт першого класу, можна зробити щось подібне:

def complicated(x, y):
    return x / y


def logged_func(func):
    def inner(x, y):
        print(f'called with {x}, {y}')
        result = func(x, y)
        print(f'result: {result}')
        return result
    return inner


complicated = logged_func(complicated)


Тепер, викликаючи complicated, ми побачимо у консолі, з якими аргументами її викликали і що вона повернула. При цьому,
код самої complicated жодним чином не змінився і спосіб роботи з нею також.

Проте такий код не занадто легкий для читання і досить об'ємний. Крім того, в коді легко пропустити рядок
complicated = logged_func(complicated) і не занадто просто зрозуміти, звідки виходитиме доданий до complicated функціонал.

Щоб спростити застосування цього шаблону проектування, в Python є спеціальний синтаксис декоратора. Точно той самий код,
який робить в точності те саме, можна записати у вигляді:

def logged_func(func):
    def inner(x, y):
        print(f'called with {x}, {y}')
        result = func(x, y)
        print(f'result: {result}')
        return result
    return inner


@logged_func
def complicated(x, y):
    return x / y


Тепер у коді явно видно, що complicated була задекорована logged_func у тому самому місці, де complicated була оголошена.