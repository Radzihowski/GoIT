# Менеджер контексту
#
# Застосунок може виконати багато операцій між відкриттям та закриттям файлу. В будь-якому місці може статися помилка та
# застосунок завершиться аварійно, не повернувши файловий дескриптор системі. Така поведінка, як вже згадувалося,
# небажана і може призводити до втрати даних.
#
# Щоб уникнути цього, можна взяти блок коду, в якому відбувається робота з файлом, у блок try ... except:

fh = open('text', 'w')
try:
    fh.write('Some data') # Виконання операцій з файлом
finally:
    fh.close() # Закриття файлу в блоку finally гарантує, що файл закриється навіть у разі помилки
#
# Цей підхід гарантує, що файл закриється, але код виглядає трохи загромадженим. Якщо станеться виняток, то обов'язково
# виконається блок finally, в якому файл буде закритий. Такий підхід гарантує, що файловий дескриптор буде обов'язково
# повернений системі. Але такий підхід не надто елегантний та читабельний.
#
# ☝ Використання конструкції with є кращою практикою, оскільки вона гарантує, що файл буде належним чином закритий після
# завершення блоку коду.
#
# Для покращення читабельності коду при збереженні функціоналу можна скористатися менеджером контексту with. Менеджер
# контексту в Python - це спосіб використання ресурсів, який автоматично забезпечує правильне закриття файлу, незалежно
# від того, чи виникла помилка чи ні. Це робить код не тільки більш читабельним, але й безпечнішим.

with open('text.txt', 'w') as fh: # Виконання операцій з файлом
    fh.write('Some data')
# Файл автоматично закриється після виходу з блоку with

# Менеджер контексту складається з ключового слова with, після якого викликається сам менеджер і, якщо щось потрібно
# повернути з менеджера, то це щось можна передати у змінну, оголошену після ключового слова as. Далі ставиться двокрапка
# і блок коду, який буде виконаний всередині менеджера. У прикладі з try ... finally — це код, який йде всередині блоку
# try. Коли код виконається, менеджер контексту виконає те, що повинен зробити в будь-якому випадку, закрити файл,
# наприклад (це те, що відбувається в блоку finally).
#
# Менеджер контексту open синтаксично повністю повторює свого класичного тезку open, вони повністю ідентичні з точки зору використання.
#
# З точки зору роботи, цей приклад робить у точності те саме, що і попередній з блоком try ... finally. Але замість
# п'яти рядків коду, ви можете написати два, і код виглядає читабельнішим. Тут with автоматично забезпечує закриття файлу,
# навіть якщо виникає помилка всередині блоку коду. Це робить код не тільки чистішим, але й безпечнішим, оскільки знижує
# ризик забути закрити файл.
# Такий спосіб роботи з файлами є рекомендованим у Python, оскільки гарантує, що програміст не забуде закрити файл у будь-якому разі.
# Перепишемо приклад, з попереднього розділу, але вже з менеджером контексту:
with open('test.txt', 'w') as fh:
    fh.write("first line\nsecond line\nthird line")
with open('test.txt', 'r') as fh:
    lines = [el.strip() for el in fh.readlines()]
print(lines)
# Як бачимо коду стало менше, він чистіше, а виведення залишилось таким самим:
# ['first line', 'second line', 'third line']
# Надалі ми будемо використовувати тільки менеджер контексту при роботі з файлами.