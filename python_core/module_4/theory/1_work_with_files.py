# Робота з файлами та обробка виключень
#
# Коли застосунок завершує свою роботу, результат його роботи, який зберігався у змінних в застосунку, буде втрачений.
# Оперативна пам'ять, яка належала застосунку, буде очищена і результат роботи втрачений. Часто нам необхідно
# зберігатирезультат роботи, щоб пізніше можна було до нього повернутися. Найпростіший спосіб зберегти корисну
# інформацію — це записати її у файл на диск. Python надає функціонал роботи з будь-якими файлами.
#
# У Python є абстракція над файлами — це вказівник на файл або файловий об'єкт. Нічого складного в цьому немає,
# це навпаки спрощує роботу з багатьма системними ресурсами.
#
# Файловий об'єкт — це системний ресурс, доступ до якого надає операційна система. Зазвичай файловий об'єкт можна відкрити
# (отримати/створити), закрити (повідомити системі, що робота з ним завершена), можна записати у нього щось і прочитати щось.
#
# Безпосередня робота з файлами у Python починається з відкриття файлу або отримання від системи доступу до файлу,
# отримання того самого файлового об'єкту. Для цього є вбудована функція open, в яку потрібно обов'язково передати ім'я
# файлу, який ми хочемо відкрити, і можна вказати, як саме ми хочемо відкрити файл:
#
fh = open('test_file.txt')
#
# В цьому прикладі fh — це файловий об'єкт, через який ми можемо працювати з файлом.
#
# Після того, як робота з файлом завершена, потрібно повернути ресурс (файл) системі. Для цього у файлового об'єкта
# потрібно викликати метод close:
#
# ✂️ Цей код можна запустити!
#
fh = open('test.txt') # операції над файлом
fh.close()
#
# Закривати файл обов'язково. Незакриті файли можуть стати причиною безлічі неочевидних проблем і складнощів.
# Найпростіший випадок — це зіпсований файл і повністю втрачена інформація, яка в ньому могла міститися.
#
# Крім того, варто пам'ятати, що оскільки файловий об'єкт — це ресурс, який надається операційною системою, то будь-яке
# завершення роботи застосунку (аварійне або штатне) не означає автоматичне закриття усіх відкритих фалів, що знову ж
# таки, може призвести до помилок.
#
# Якщо не вказати, як ми хочемо відкрити файл, то він відкривається тільки для зчитування даних і за допомогою fh можна
# буде тільки читати дані з файлу. Якщо файлу з ім'ям test_file.txt в системі немає, то ви отримаєте виняток.
#
# Після короткого огляду, розглянемо синтаксис функції open() більш детально. Функція open() повертає файловий об'єкт,
# який далі може бути використаний для читання з файлу або запису в нього.
#
# open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

# Параметри:
# file - шлях до файлу у вигляді рядка. Це може бути повний шлях або шлях відносно поточного каталогу виконання.
# mode (необов'язковий) - режим, в якому буде відкрито файл. Ось основні режими які ми будемо використовувати:
# 'r' - читання (за замовчуванням). Файл має існувати.
# 'w' - запис. Створює новий файл або перезаписує, що вже існує.
# 'a' - додавання. Дописує в кінець файлу, не перезаписуючи його.
# 'b' - бінарний режим (може бути використаний разом з іншими, наприклад 'rb' або 'wb').
# '+' - оновлення (читання та запис).
# buffering (необов'язковий) - визначає буферизацію: 0 для вимкненої, 1 для включеної буферизації рядків, більше 1 для
# вказання розміру буфера у байтах.
# encoding (необов'язковий) - ім'я кодування, яке буде використовуватися для кодування або декодування файлу.
# errors (необов'язковий) - вказує, як обробляти помилки кодування.
# newline (необов'язковий) - контролює, як обробляються нові рядки.
# closefd (необов'язковий) - має бути True (за замовчуванням); якщо вказано False, файловий дескриптор не буде закритий.
# opener (необов'язковий) - визначає спеціальну функцію для відкриття файлу.
#
# Насправді нам не потрібні будуть всі параметри, зазвичай нам буде достатньо для використання перших двох.
#

# Наприклад, щоб відкрити файл для запису або створити новий, якщо його немає, або перезаписати файл, можна вказати значення режиму w:
# ✂️ Цей код можна запустити!
#
fh = open('test.txt', 'w')
symbols_written = fh.write('hello!')
print(symbols_written) # 6
fh.close()

# В цьому прикладі ми створили (або перезаписали, якщо він вже існував) файл test.txt для запису та записали туди рядок
# 'hello!' завдовжки 6 символів. Для запису даних у файл ми використали метод write у об'єкта fh. Цей метод повертає
# кількість записаних у файл символів - в нашому випадку число 6.
#
# Парний до нього метод — це метод read, який дозволяє прочитати деяку кількість символів із файлу.
#
# ✂️ Цей код можна запустити!
fh = open('test.txt', 'w+')
fh.write('hello!')
fh.seek(0)

first_two_symbols = fh.read(2)
print(first_two_symbols)  # 'he'

fh.close()

# В цьому прикладі ми відкрили файл в режимі для читання та запису, але сам файл ми перезаписуємо, якщо він існує, бо
# використовується режим w+. Записали у файл рядок 'hello!' та прочитали перші два символи із файлу за допомогою методу
# read, вказавши у якості аргументу двійку. Метод read повертає прочитанні символи і оскільки ми прочитали 2 символи,
# то змінна first_two_symbols буде зберігати рядок "he". Для того, щоб повернути вказівник на початок файлу ми викликали
# метод seek та передали йому позицію, куди потрібно переміститися 0. Трошки далі ми розглянемо його детальніше.
#
# Щоб прочитати увесь вміст файлу за раз, можна викликати метод read без аргументів:
#
# ✂️ Цей код можна запустити!
fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
all_file = fh.read()
print(all_file)  # 'hello!'

fh.close()
# Доки файловий дескриптор не закритий, ви можете читати із нього частинами, продовжуючи читання з того самого місця,
# на якому зупинилися:
# ✂️ Цей код можна запустити!
fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
while True:
    symbol = fh.read(1)
    if len(symbol) == 0:
        break
    print(symbol)

fh.close()
# В цьому прикладі у циклі ми зчитували та виводили у консоль вміст файлу по одному символу за раз. В результаті ви
# отримаєте у консолі, в стовпчик, всі символи файлу:
# h
# e
# l
# l
# o
# !
# Ще є зручний спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline:
# ✂️ Цей код можна запустити!

fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
while True:
    line = fh.readline()
    if not line:
        break
    print(line)

fh.close()

# У циклі while True виконується неперервне читання з файлу. Метод readline() читає один рядок з файлу за раз. Якщо
# readline() повертає порожній рядок, це означає, що досягнуто кінця файлу, тому цикл переривається за допомогою break.
# Кожен прочитаний рядок виводиться на екран. Оскільки readline() зберігає символи переходу на новий рядок, кожен
# виведений рядок буде виведено з нового рядка.
#
# В консолі буде виведення:
# first line
# second line
# third line

# Та аналогічний метод readlines, який читає увесь файл повністю, але повертає список рядків, де елемент списку — це один рядок з файлу.
# ✂️ Цей код можна запустити!
#
# fh = open('test.txt', 'w')
# fh.write('first line\nsecond line\nthird line')
# fh.close()
#
# fh = open('test.txt', 'r')
# lines = fh.readlines()
# print(lines)
#
# fh.close()
#
# Виведення у консолі буде:
# ['first line\n', 'second line\n', 'third line']
#
# Зверніть увагу, що всі методи, які читають файли порядково, залишають (не видаляють) символ перенесення рядка \n. Його, за необхідності, треба видаляти самостійно:
#
# ✂️ Цей код можна запустити!
fh = open("test.txt", "w")
fh.write("first line\nsecond line\nthird line")
fh.close()

fh = open("test.txt", "r")
lines = [el.strip() for el in fh.readlines()]
print(lines)

fh.close()

# Тут ми для видалення символу переносу рядка \n використали метод strip() і тепер виведення в нас чисте:
# ['first line', 'second line', 'third line']
#
# Тепер повернемось до детального розгляду метода seek. Python дає можливість управляти положенням курсора (вказівника)
# у файлі та довільно переміщатися файлом за допомогою методу seek. Цей метод приймає один аргумент — це кількість символів, на які потрібно змістити курсор у файлі:
#
# ✂️ Цей код можна запустити!
#
fh = open('test.txt', 'w+')
fh.write('hello!')

fh.seek(1)
second = fh.read(1)
print(second)  # 'e'

fh.close()

# В цьому прикладі після запису у файл курсор буде зупинений на останньому символі. У виразі fh.seek(1) ми перемістили курсор на другий символ у файлі. Переміщаючи курсор, можна перезаписувати символи файлу або читати записане.
#
# Метод seek може приймати опціонально другий аргумент, який буде вказувати, звідки потрібно зчитати зміщення. За замовчуванням зміщення задається від початку файлу, але можна задати з кінця або з поточного положення. На жаль, зазначення зміщення з кінця файлу не на всіх платформах підтримується і краще використовувати варіант за замовчуванням.

# Щоб дізнатися положення курсора в цей момент, можна скористатися методом tell, він повертає позицію (номер) символу з початку файлу, де зараз знаходиться курсор.
# ✂️ Цей код можна запустити!
#
fh = open("test.txt", "w+")
fh.write("hello!")

position = fh.tell()
print(position)  # 6

fh.seek(1)
position = fh.tell()
print(position)  # 1

fh.read(2)
position = fh.tell()
print(position)  # 3

fh.close()

# Виведення:
#
# 6
# 1
# 3

